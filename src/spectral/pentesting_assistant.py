"""
Pentesting Assistant - Conversational Pentesting Methodology Layer.

Enforces systematic methodology with NO hardcoded shortcuts:
- ALWAYS asks clarifying questions FIRST
- Code only generates AFTER methodology is clear
- Autonomous execution when info is sufficient
- Context-aware and persistent across turns

Methodology Stages:
1. RECONNAISSANCE: Gather basic target info (IP, OS type)
2. ENUMERATION: Discover services, ports, versions
3. VULNERABILITY_ASSESSMENT: Research CVEs and exploits
4. METHODOLOGY_SELECTION: Choose exploitation approach
5. EXPLOITATION: Execute chosen method
6. POST_EXPLOITATION: Maintain access, escalate privileges

Key Rules:
- NEVER generate payloads instantly - ask 5+ clarifying questions first
- NEVER try code execution without understanding methodology
- ALWAYS explain exploitation path before generating code
- ASK about delivery method, callback type, target network, obfuscation
- PRIORITIZE methodology reasoning over instant code generation
"""

import logging
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

from spectral.llm_client import LLMClient

logger = logging.getLogger(__name__)


class ExploitStage(Enum):
    """Stages of penetration testing engagement."""

    RECONNAISSANCE = "reconnaissance"
    ENUMERATION = "enumeration"
    VULNERABILITY_ASSESSMENT = "vulnerability_assessment"
    METHODOLOGY_SELECTION = "methodology_selection"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"


@dataclass
class TargetInfo:
    """Information about the penetration test target."""

    ip_address: Optional[str] = None
    hostname: Optional[str] = None
    os_type: Optional[str] = None  # Windows, Linux, macOS, Android, iOS
    os_version: Optional[str] = None  # 10, 11, 20.04, etc.
    architecture: Optional[str] = None  # x86, x64, ARM, etc.
    services: List[str] = field(default_factory=list)
    open_ports: List[int] = field(default_factory=list)
    service_versions: Dict[str, str] = field(default_factory=dict)
    credentials: List[Dict[str, str]] = field(default_factory=list)
    network_location: Optional[str] = None  # Internal, DMZ, External
    access_level: Optional[str] = None  # Unauthenticated, User, Admin
    cves: List[str] = field(default_factory=list)
    known_vulnerabilities: List[str] = field(default_factory=list)

    def to_summary(self) -> str:
        """Generate a human-readable summary of target info."""
        parts = []

        if self.ip_address:
            parts.append(f"IP: {self.ip_address}")
        if self.hostname:
            parts.append(f"Hostname: {self.hostname}")
        if self.os_type:
            os_str = f"OS: {self.os_type}"
            if self.os_version:
                os_str += f" {self.os_version}"
            parts.append(os_str)
        if self.architecture:
            parts.append(f"Arch: {self.architecture}")
        if self.services:
            parts.append(f"Services: {', '.join(self.services)}")
        if self.open_ports:
            parts.append(f"Ports: {', '.join(map(str, self.open_ports))}")
        if self.network_location:
            parts.append(f"Network: {self.network_location}")
        if self.access_level:
            parts.append(f"Access: {self.access_level}")

        return "\n".join(f"  • {part}" for part in parts) if parts else "  No target info yet"


@dataclass
class ExploitMethodology:
    """Chosen exploitation methodology with parameters."""

    exploit_type: Optional[str] = None  # CVE, brute-force, default creds, etc.
    delivery_method: Optional[str] = None  # EXE, PowerShell, DLL, batch, macro, etc.
    callback_type: Optional[str] = None  # Reverse TCP, Reverse HTTPS, Bind shell, etc.
    obfuscation: Optional[bool] = None
    payload_format: Optional[str] = None  # exe, elf, apk, script, etc.
    staging_required: Optional[bool] = None
    risk_assessment: Optional[str] = None


class PentestingAssistant:
    """
    Conversational pentesting assistant with enforced methodology.

    CRITICAL: NEVER use hardcoded shortcuts.
    ALWAYS ask clarifying questions FIRST.
    """

    def __init__(self, llm_client: LLMClient, research_handler=None, semantic_classifier=None) -> None:
        """
        Initialize the pentesting assistant.

        Args:
            llm_client: LLM for reasoning and conversation
            research_handler: Research handler for vulnerability lookups
            semantic_classifier: Semantic intent classifier
        """
        self.llm_client = llm_client
        self.research_handler = research_handler
        self.semantic_classifier = semantic_classifier

        self.target: Optional[TargetInfo] = None
        self.methodology: Optional[ExploitMethodology] = None
        self.stage = ExploitStage.RECONNAISSANCE
        self.conversation_history: List[Dict[str, str]] = []

        logger.info("PentestingAssistant initialized with methodology enforcement")

    def handle_pentest_request(self, user_message: str) -> str:
        """
        Handle a penetration testing request through intelligent conversation.

        This is the main entry point - enforced NO hardcoded shortcuts.

        Args:
            user_message: User's request (e.g., "test my Windows machine")

        Returns:
            AI's response (clarifying question, finding, or methodology explanation)
        """
        logger.info(f"Pentest request: {user_message}")

        # Check for context clear commands
        if self._is_context_clear_command(user_message):
            self._clear_context()
            return "Context cleared. Ready for a new target. What would you like to test?"

        # Add to conversation history
        self.conversation_history.append({"role": "user", "content": user_message})

        # Determine current stage and what's needed
        response = self._stage_handler(user_message)

        # Add AI response to history
        self.conversation_history.append({"role": "assistant", "content": response})

        return response

    def _is_context_clear_command(self, user_message: str) -> bool:
        """Check if user wants to clear context."""
        clear_patterns = [
            r"\bforget\b",
            r"\bnew target\b",
            r"\bdifferent machine\b",
            r"\breset\b",
            r"\bclear\b.*\bcontext\b",
            r"\bstart over\b",
        ]
        return any(re.search(pattern, user_message, re.IGNORECASE) for pattern in clear_patterns)

    def _clear_context(self) -> None:
        """Clear all pentesting context."""
        self.target = None
        self.methodology = None
        self.stage = ExploitStage.RECONNAISSANCE
        self.conversation_history.clear()
        logger.info("Pentesting context cleared")

    def _stage_handler(self, user_message: str) -> str:
        """
        Route to appropriate stage handler based on what info we have.

        Enforces methodology by asking questions before moving to next stage.
        """
        # Parse user message for any target info
        self._parse_user_message(user_message)

        # Route based on current stage and available info
        if not self.target or not self.target.ip_address:
            return self._reconnaissance_stage(user_message)

        elif not self.target.os_type or not self.target.os_version:
            return self._enumerate_os_stage(user_message)

        elif not self.target.services or not self.target.open_ports:
            return self._enumerate_services_stage(user_message)

        elif not self.methodology:
            return self._methodology_selection_stage(user_message)

        else:
            return self._exploitation_stage(user_message)

    def _parse_user_message(self, user_message: str) -> None:
        """Parse user message for target information."""
        # Initialize target if needed
        if not self.target:
            self.target = TargetInfo()

        # Parse IP address
        ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
        ip_match = re.search(ip_pattern, user_message)
        if ip_match:
            self.target.ip_address = ip_match.group()
            logger.info(f"Target IP identified: {self.target.ip_address}")

        # Parse OS type
        os_keywords = {
            r"\bwindows\s*(\d+)": ("Windows", "os_version"),
            r"\bwindows\b": ("Windows", None),
            r"\blinux\b": ("Linux", None),
            r"\bubuntu\s+([\d.]+)": ("Linux", "os_version"),
            r"\bubuntu\b": ("Linux", None),
            r"\bcentos\b": ("Linux", None),
            r"\bdebian\b": ("Linux", None),
            r"\bmacos\b": ("macOS", None),
            r"\bmac\b": ("macOS", None),
            r"\bandroid\b": ("Android", None),
            r"\bios\b": ("iOS", None),
        }

        for pattern, (os_name, version_field) in os_keywords.items():
            match = re.search(pattern, user_message, re.IGNORECASE)
            if match:
                self.target.os_type = os_name
                if version_field and match.groups():
                    setattr(self.target, version_field, match.group(1))
                logger.info(f"OS identified: {os_name} {match.group(1) if match.groups() else ''}")
                break

        # Parse services
        service_keywords = {
            "ssh": 22,
            "rdp": 3389,
            "smb": 445,
            "http": 80,
            "https": 443,
            "ftp": 21,
            "telnet": 23,
            "mysql": 3306,
            "postgresql": 5432,
            "mongodb": 27017,
            "redis": 6379,
            "vnc": 5900,
            "nfs": 2049,
            "dns": 53,
            "smtp": 25,
        }

        for service, port in service_keywords.items():
            if service in user_message.lower():
                if service.upper() not in self.target.services:
                    self.target.services.append(service.upper())
                if port not in self.target.open_ports:
                    self.target.open_ports.append(port)
                logger.info(f"Service identified: {service} on port {port}")

    def _reconnaissance_stage(self, user_message: str) -> str:
        """
        Stage 1: Ask for basic target information.

        NEVER skip this - always ask for:
        1. Target IP/hostname
        2. OS type
        3. Basic goal
        """

        if not self.target:
            self.target = TargetInfo()

        # If we have some info but not all, ask for what's missing
        missing_info = []

        if not self.target.ip_address and not self.target.hostname:
            missing_info.append("Target IP address or hostname")
        if not self.target.os_type:
            missing_info.append("Operating system (Windows, Linux, macOS, etc.)")

        if missing_info:
            return (
                "I'll help you conduct a systematic penetration test. "
                "First, I need to establish the target:\n\n"
                "**Missing Information:**\n" + "\n".join(f"  • {item}" for item in missing_info) + "\n\n"
                "**Please provide:**\n"
                "1. Target IP address (e.g., 192.168.1.100)\n"
                "2. Operating system (Windows 10/11, Ubuntu 20.04, macOS, etc.)\n"
                "3. What's your access level? (No access, user account, admin, etc.)\n\n"
                "This information helps me determine the appropriate testing methodology."
            )

        # If we have basic info, move to next stage
        if self.target.ip_address:
            return self._enumerate_os_stage(user_message)

        return "Please provide the target IP address or hostname to begin."

    def _enumerate_os_stage(self, user_message: str) -> str:
        """
        Stage 2: Ask for detailed OS information.

        CRITICAL: Ask for version, architecture, patches before proceeding.
        """

        missing_details = []

        if not self.target.os_type:
            missing_details.append("Operating system type (Windows, Linux, macOS, etc.)")
        if not self.target.os_version:
            missing_details.append("OS version (e.g., Windows 10 21H2, Ubuntu 20.04 LTS)")

        if missing_details:
            return (
                f"Good, I have the target identified:\n\n"
                f"{self.target.to_summary()}\n\n"
                f"Now I need more OS-specific details:\n\n"
                + "\n".join(f"  • {item}" for item in missing_details)
                + "\n\n"
                "**Why this matters:**\n"
                "- Different OS versions have different vulnerabilities\n"
                "- Patch levels determine which CVEs are applicable\n"
                "- Architecture (x86/x64) affects payload format\n\n"
                "What OS version is your target running?"
            )

        # If we have OS info, move to service enumeration
        return self._enumerate_services_stage(user_message)

    def _enumerate_services_stage(self, user_message: str) -> str:
        """
        Stage 3: Ask for running services and open ports.

        CRITICAL: Don't skip this - need to know what's exposed before choosing exploit.
        """

        if not self.target:
            return "Target information lost. Please start over with target details."

        # Check if we have service info
        if not self.target.services and not self.target.open_ports:
            return (
                f"Target identified:\n{self.target.to_summary()}\n\n"
                f"**Service Enumeration Needed:**\n\n"
                f"To determine the best exploitation approach, I need to know:\n\n"
                f"1. **What services are running?**\n"
                f"   - Common services: SSH (22), RDP (3389), SMB (445), HTTP/HTTPS (80/443)\n"
                f"   - Database services: MySQL (3306), PostgreSQL (5432)\n"
                f"   - Other: FTP, Telnet, VNC, etc.\n\n"
                f"2. **Service versions** (if known):\n"
                f"   - E.g., 'Apache 2.4.41', 'OpenSSH 7.4', 'nginx 1.18'\n\n"
                f"3. **Can you scan the target?**\n"
                f"   - If yes, run: `nmap -sV -sC {self.target.ip_address}`\n"
                f"   - Share the results with me\n\n"
                f"Service enumeration is critical for selecting the right exploit."
            )

        # We have some service info
        return (
            f"Target and services identified:\n{self.target.to_summary()}\n\n"
            f"**Let me verify the service information:**\n\n"
            f"Are these all the services you found? Any additional details:\n"
            f"- Service versions?\n"
            f"- Any custom or unusual services?\n"
            f"- Any firewall or network restrictions?\n\n"
            f"This helps me narrow down the most effective exploitation vectors."
        )

    def _methodology_selection_stage(self, user_message: str) -> str:
        """
        Stage 4: Select exploitation methodology.

        CRITICAL: Ask 5+ clarifying questions BEFORE generating any code/payload:
        1. Delivery method preference?
        2. Callback type?
        3. Obfuscation needed?
        4. Payload format?
        5. Network location/context?
        6. Risk tolerance?
        """

        # Initialize methodology if needed
        if not self.methodology:
            self.methodology = ExploitMethodology()

        # Check what methodology questions remain
        missing_methodology_info = []

        if not self.methodology.delivery_method:
            missing_methodology_info.append("Delivery method (EXE, PowerShell, DLL, batch, macro, etc.)")

        if not self.methodology.callback_type:
            missing_methodology_info.append("Callback type (Reverse TCP, Reverse HTTPS, Bind shell, etc.)")

        if self.methodology.obfuscation is None:
            missing_methodology_info.append("Obfuscation/encoding (Yes/No - affects detection)")

        if not self.methodology.payload_format:
            missing_methodology_info.append("Payload format (exe, elf, script, etc.)")

        if not self.target.network_location:
            missing_methodology_info.append("Target network location (Internal, DMZ, External)")

        if missing_methodology_info:
            return (
                f"**Target Summary:**\n{self.target.to_summary()}\n\n"
                f"**Services:** {', '.join(self.target.services) if self.target.services else 'None identified'}\n\n"
                f"**Methodology Selection**\n\n"
                f"Before I generate any exploit or payload, I need to understand your requirements:\n\n"
                + "\n".join(f"  • {item}" for item in missing_methodology_info)
                + "\n\n"
                "**Additional context:**\n"
                "- Are there AV/EDR solutions on the target?\n"
                "- What's your risk tolerance for detection?\n"
                "- Do you need persistence or just one-time access?\n\n"
                "**Why these questions matter:**\n"
                "- Delivery method determines how we get the payload to the target\n"
                "- Callback type affects how we maintain the connection\n"
                "- Obfuscation impacts AV/EDR evasion\n"
                "- Payload format must match the target OS and architecture\n"
                "- Network location affects connectivity and firewall rules\n\n"
                "Please provide these details so I can recommend the best approach."
            )

        # If we have all methodology info, move to exploitation
        return self._exploitation_stage(user_message)

    def _exploitation_stage(self, user_message: str) -> str:
        """
        Stage 5: Generate and explain exploitation strategy.

        CRITICAL: Only generate code AFTER:
        - All target info is complete
        - Methodology questions are answered
        - Exploitation path is explained

        This stage explains the methodology and generates code ONLY when appropriate.
        """

        if not self.target or not self.methodology:
            return "Target or methodology information incomplete. Please start over."

        # Use LLM to reason through the exploitation strategy
        strategy_prompt = self._build_strategy_prompt()

        try:
            ai_strategy = self.llm_client.generate(strategy_prompt)

            logger.info(f"AI Strategy Generated for {self.target.ip_address}")

            # Add context header
            response = (
                f"**Exploitation Strategy for Target: {self.target.ip_address}**\n\n"
                f"{self.target.to_summary()}\n\n"
                f"**Chosen Methodology:**\n"
                f"  • Delivery: {self.methodology.delivery_method}\n"
                f"  • Callback: {self.methodology.callback_type}\n"
                f"  • Payload Format: {self.methodology.payload_format}\n"
                f"  • Obfuscation: {'Yes' if self.methodology.obfuscation else 'No'}\n\n"
                f"---\n\n"
                f"{ai_strategy}"
            )

            return response

        except Exception as e:
            logger.error(f"Failed to generate exploitation strategy: {e}")
            return (
                f"Target and methodology identified, but I encountered an error generating the strategy.\n\n"
                f"Error: {str(e)}\n\n"
                f"Please try again or rephrase your request."
            )

    def _build_strategy_prompt(self) -> str:
        """Build the exploitation strategy prompt for the LLM."""

        prompt = f"""You are an expert penetration tester. Explain the exploitation methodology for this target:

**Target Information:**
- IP: {self.target.ip_address}
- OS: {self.target.os_type} {self.target.os_version or ''}
- Architecture: {self.target.architecture or 'Unknown'}
- Services: {', '.join(self.target.services) if self.target.services else 'None'}
- Open Ports: {', '.join(map(str, self.target.open_ports)) if self.target.open_ports else 'None'}
- Network Location: {self.target.network_location or 'Unknown'}
- Access Level: {self.target.access_level or 'Unauthenticated'}

**Service Versions:**
{self.target.service_versions or 'None provided'}

**Known Vulnerabilities/CVEs:**
{', '.join(self.target.cves) if self.target.cves else 'None identified'}

**Methodology Requirements:**
- Delivery Method: {self.methodology.delivery_method}
- Callback Type: {self.methodology.callback_type}
- Payload Format: {self.methodology.payload_format}
- Obfuscation: {'Yes' if self.methodology.obfuscation else 'No'}

**Your Task:**
1. Analyze the target and identify the BEST exploitation vectors
2. Explain WHY this method is most effective for this specific configuration
3. Describe the exploitation chain step-by-step
4. Identify risk factors (AV/EDR, detection, stability)
5. Provide specific commands or code ONLY IF this is a standard exploit
6. For Metasploit exploits, provide the exact module name and configuration options
7. For custom exploits, explain what the code will do

**Output Format:**
**Exploitation Analysis:**
[Your detailed reasoning about why this approach is best for this target]

**Recommended Exploit Chain:**
[Step-by-step breakdown of the exploitation process]

**Implementation:**
[If using a known exploit framework like Metasploit, provide exact commands]
[If custom code is needed, explain what the code will accomplish]
[Only generate actual code if you're confident it will work for this target]

**Risk Assessment:**
[AV/EDR detection risk, network monitoring, stability concerns]

**Post-Exploitation:**
[Suggested next steps once access is gained]

CRITICAL: Do NOT generate code just to generate code. Only provide
implementation details when you have high confidence the exploit will work
for this specific target configuration."""

        return prompt

    def update_target_info(self, field: str, value: Any) -> None:
        """
        Update specific target field.

        Args:
            field: Field name to update
            value: New value
        """
        if not self.target:
            self.target = TargetInfo()

        if hasattr(self.target, field):
            setattr(self.target, field, value)
            logger.info(f"Updated target {field}: {value}")

    def update_methodology(self, field: str, value: Any) -> None:
        """
        Update specific methodology field.

        Args:
            field: Field name to update
            value: New value
        """
        if not self.methodology:
            self.methodology = ExploitMethodology()

        if hasattr(self.methodology, field):
            setattr(self.methodology, field, value)
            logger.info(f"Updated methodology {field}: {value}")

    def get_target_summary(self) -> str:
        """Get a formatted summary of current target information."""
        if not self.target:
            return "No target information available."

        return f"**Target Summary:**\n{self.target.to_summary()}"

    def get_methodology_summary(self) -> str:
        """Get a formatted summary of current methodology."""
        if not self.methodology:
            return "No methodology selected yet."

        parts = []

        if self.methodology.delivery_method:
            parts.append(f"  • Delivery: {self.methodology.delivery_method}")
        if self.methodology.callback_type:
            parts.append(f"  • Callback: {self.methodology.callback_type}")
        if self.methodology.payload_format:
            parts.append(f"  • Payload: {self.methodology.payload_format}")
        if self.methodology.obfuscation is not None:
            parts.append(f"  • Obfuscation: {'Yes' if self.methodology.obfuscation else 'No'}")

        return "\n".join(parts) if parts else "No methodology details set yet"
